import inspect
import os
from pathlib import Path

from django.conf import settings
from django.contrib.auth.models import AnonymousUser
from django.contrib.sessions.backends.cache import SessionStore
from django.core.checks import Error, Warning, register
from django.db import ProgrammingError
from django.forms import ModelForm

import structlog
from psycopg.errors import DatabaseError
from rest_framework.serializers import CharField, Serializer, empty
from rest_framework.test import APIRequestFactory
from treebeard.forms import MoveNodeForm

logger = structlog.stdlib.get_logger(__name__)


def get_subclasses(cls):
    for subclass in cls.__subclasses__():
        yield from get_subclasses(subclass)
        yield subclass


@register()
def check_modelform_exclude(app_configs, **kwargs):
    """
    Check that ModelForms use Meta.fields instead of Meta.exclude.

    ModelForm.Meta.exclude is dangerous because it doesn't protect against
    fields that are added later. Explicit white-listing is safer and prevents
    bugs such as IMA #645.

    This check piggy-backs on all form modules to be imported during Django
    startup. It won't cover forms that are defined on the fly such as in
    formset factories.
    """
    errors = []

    for form in get_subclasses(ModelForm):
        # MoveNodeForm is generated by treebeard and doesn't pass checks
        if issubclass(form, MoveNodeForm):
            continue
        # ok, fields is defined
        if form._meta.fields or getattr(form.Meta, "fields", None):
            continue

        # no `.fields` defined, so scream loud enough to prevent this
        errors.append(
            Error(
                f"ModelForm {form.__module__}.{form.__name__} with Meta.exclude detected, this is a bad practice",
                hint="Use ModelForm.Meta.fields instead",
                obj=form,
                id="utils.E001",
            )
        )

    return errors


@register
def check_missing_init_files(app_configs, **kwargs):
    """
    Check that all packages have __init__.py files.

    If they don't, the code will still run, but tests aren't picked up by the
    test runner, for example.
    """
    errors = []

    for dirpath, _, filenames in os.walk(settings.DJANGO_PROJECT_DIR):
        dirname = os.path.split(dirpath)[1]
        if dirname == "__pycache__":
            continue

        if "__init__.py" in filenames:
            continue

        extensions = [os.path.splitext(fn)[1] for fn in filenames]
        if ".py" not in extensions:
            continue

        errors.append(
            Warning(
                f"Directory '{dirpath}' does not contain an `__init__.py` file",
                hint="Consider adding this module to make sure tests are picked up",
                id="utils.W001",
            )
        )

    return errors


def is_subpath(*, parent: Path, child: str) -> bool:
    try:
        Path(child).relative_to(parent)
    except ValueError:
        return False
    return True


@register
def check_serializer_non_required_charfield_allow_blank_true(  # pragma: no cover
    app_configs, **kwargs
):
    """
    Check for serializers.CharFields that have ``required=False``, but not ``allow_blank=True``
    to avoid bogus validation errors occurring when empty strings are provided by the frontend.
    """
    request = APIRequestFactory().get("/")
    request.user = AnonymousUser()
    request.session = SessionStore()

    errors = []
    serializers = get_subclasses(Serializer)
    for serializer_class in serializers:
        serializer_defined_in = inspect.getfile(serializer_class)
        if not is_subpath(
            parent=settings.DJANGO_PROJECT_DIR, child=serializer_defined_in
        ):
            continue  # ignore code not defined in our own codebase

        if hasattr(serializer_class, "Meta") and not hasattr(
            serializer_class.Meta, "model"
        ):
            continue

        try:
            serializer = serializer_class(context={"request": request})
            fields = serializer.fields
        except (ProgrammingError, DatabaseError) as exc:
            logger.debug(
                "serializer_instantation_failure",
                serializer=serializer_class,
                exc_info=exc,
            )
            continue

        for field_name, field in fields.items():
            if not isinstance(field, CharField) or field.read_only:
                continue

            if (
                not field.required
                and field.default in ("", None, empty)
                and not field.allow_blank
            ):
                file_path = inspect.getfile(serializer_class)

                errors.append(
                    Warning(
                        (
                            f"{serializer_class.__module__}.{serializer_class.__qualname__}.{field_name} does not have `allow_blank=True`\n"
                            f"{file_path}"
                        ),
                        hint="Consider setting `allow_blank=True` to allow providing empty string values",
                        id="utils.W002",
                    )
                )
    return errors
